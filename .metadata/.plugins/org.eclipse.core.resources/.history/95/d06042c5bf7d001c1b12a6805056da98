/**
 * Q1. Implement singleton design pattern, to ensure that a class have only one instance
and provide global point of access to it
While designing singleton pattern consider following factors, what is good progamming 
practice about singleton pattern?

1.	Eager initialization
2.	Static block initialization
3.	Lazy Initialization
4.	Thread Safe Singleton
5.	Serialization issue
6.	Cloning issue
7.	Using Reflection to destroy Singleton Pattern
8.	Enum Singleton
 * **/

package com.milestone2.q1;

import java.io.Serializable;

enum MySingleton {
	INSTANCE;
	//
}

class Singleton implements Serializable, Cloneable {
	private static final long serialVersionUID = 1L;
	private static volatile Singleton singleton1 = null;

	private Singleton() {
		if (singleton1 != null) {
			throw new IllegalStateException();
		}
	}

	public static Singleton1 getSingleton10() {
		if (singleton1 == null) {
			if (singleton1 == null) {
				synchronized (Singleton.class) {
					singleton1 = new Singleton();
				}
			}
		}
		return singleton1;
	}

	private Object readResolve() {
		return singleton1;
	}

	@Override
	protected Object clone() throws CloneNotSupportedException {
		return singleton1;
	}
}

public class Question01 {

}
